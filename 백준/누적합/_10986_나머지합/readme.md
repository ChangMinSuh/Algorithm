# 나머지합

- https://www.acmicpc.net/problem/10986

## 해설

누적합, 해시맵


- 누적합을 만들고 하나하나씩 계산하면 정답. 하지만 시간초과
    - ex) sum[] = {2, 0, 2, 0} M = 3;
    - 0 ~ N = sum[0], sum[1], sum[2], sum3[3]. 각각 M으로 나눠서 0이 나오면 출력
    - 1 ~ N = sum[1], sum[2], sum[3] 에 sum[0] 빼줌. 각각 M으로 나눠서 0이 나오면 출력
    - 2 ~ N = sum[2], sum[3] 에 sum[1] 빼줌. 각각 M으로 나눠서 0이 나오면 출력
    - 결국 2중 포문으로 시간초과..

- 역으로 M 값을 움직이면 됨. sum과 map은 그대로 두고, 가져올 값을 바꿈.
    - 0 ~ N = sum[0], sum[1], sum[2]. sum3[3]. 이떄 각 sum을 % M 하여 map에 저장.
        - map에 sum의 결과(key)와 개수(value)를 저장 후,  0인경우가 나눠 떨어진 경우이다.
    - 1 ~ N = sum[1], sum[2], sum[3]
        - map의 값을 변경하는 대신 나눌 값을 변경한다.
            - (전에 나눈값 + sum[0]) % M => 이값을 map에서 get하면 그값이 나눠 떨어지는 수이다.

    - 2 ~ N  도 위처럼 반복

- sum변수를 이용해 누적합 저장
- sumMap변수를 이용해 누적합의 개수를 저장
